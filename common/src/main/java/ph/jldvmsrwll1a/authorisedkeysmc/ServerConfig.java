package ph.jldvmsrwll1a.authorisedkeysmc;

import java.io.*;
import java.nio.file.Files;
import java.util.Optional;
import java.util.Properties;

import org.jspecify.annotations.Nullable;
import ph.jldvmsrwll1a.authorisedkeysmc.util.WriteUtil;

public final class ServerConfig {
    private static final Object WRITE_LOCK = new Object();

    public volatile boolean enforcing = true;
    public volatile int loginTimeoutTicks = 1200;
    public volatile int maxKeyCount = 100;
    public volatile boolean registrationRequired = false;
    public volatile boolean allowRegistration = true;
    public volatile boolean skipOnlineAccounts = false;
    public volatile @Nullable String kickMessage = null;

    public static ServerConfig fromDisk() {
        ServerConfig config = new ServerConfig();
        Properties props = new Properties();

        synchronized (WRITE_LOCK) {
            try (FileReader file = new FileReader(AkmcCore.FILE_PATHS.CONFIG_PATH.toFile())) {
                props.load(file);
            } catch (FileNotFoundException e) {
                return config;
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        parseBooleanStrictly(props, "enforcing").ifPresent(bool -> config.enforcing = bool);
        parseUnsignedInteger(props, "login_timeout_ticks").ifPresent(value -> config.loginTimeoutTicks = value);
        parseUnsignedInteger(props, "max_key_count").ifPresent(value -> config.maxKeyCount = value);
        parseBooleanStrictly(props, "registration_required").ifPresent(bool -> config.registrationRequired = bool);
        parseBooleanStrictly(props, "allow_registration").ifPresent(bool -> config.allowRegistration = bool);
        parseBooleanStrictly(props, "skip_online_accounts").ifPresent(bool -> config.skipOnlineAccounts = bool);

        String kickMessage = props.getProperty("kick_message");
        if (kickMessage != null && kickMessage.isBlank()) {
            kickMessage = null;
        }
        config.kickMessage = kickMessage;

        return config;
    }

    public void write() {
        StringBuilder builder = new StringBuilder();
        builder.append("# AKMC Server Configuration\n#\n");
        builder.append("# This file is automatically generated.\n#\n\n");
        builder.append("enforcing = ");
        builder.append(enforcing ? "true\n" : "false\n");
        builder.append("login_timeout_ticks = %s\n".formatted(loginTimeoutTicks));
        builder.append("max_key_count = %s\n".formatted(maxKeyCount));
        builder.append("registration_required = ");
        builder.append(registrationRequired ? "true\n" : "false\n");
        builder.append("allow_registration = ");
        builder.append(allowRegistration ? "true\n" : "false\n");
        builder.append("skip_online_accounts = ");
        builder.append(skipOnlineAccounts ? "true\n" : "false\n");
        builder.append("kick_message = ");
        builder.append(kickMessage != null ? kickMessage : "");
        builder.append('\n');

        synchronized (WRITE_LOCK) {
            try {
                Files.createDirectories(AkmcCore.FILE_PATHS.CONFIG_DIR);
                WriteUtil.writeString(AkmcCore.FILE_PATHS.CONFIG_PATH, builder);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        Constants.LOG.info("AKMC: wrote server config.");
    }

    private static Optional<Boolean> parseBooleanStrictly(Properties properties, String key) {
        String value = properties.getProperty(key);

        if (value == null) {
            return Optional.empty();
        }

        value = value.strip();

        if (value.equalsIgnoreCase("true")) {
            return Optional.of(true);
        } else if (value.equalsIgnoreCase("false")) {
            return Optional.of(false);
        } else {
            throw new IllegalStateException("Invalid boolean for property '%s'".formatted(key));
        }
    }

    private static Optional<Integer> parseUnsignedInteger(Properties properties, String key) {
        String value = properties.getProperty(key);

        if (value == null) {
            return Optional.empty();
        }

        try {
            return Optional.of(Integer.parseUnsignedInt(value.strip()));
        } catch (NumberFormatException e) {
            throw new IllegalStateException("Invalid unsigned integer for '%s'".formatted(key), e);
        }
    }
}
